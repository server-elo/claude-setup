"""
Test Runner Module

This module is responsible for executing adversarial prompts against the target LLM application.
It handles different types of API endpoints and authentication methods.
"""

import json
import logging
import requests
from typing import Dict, Any, Optional
from playwright.sync_api import sync_playwright
from tenacity import retry, stop_after_attempt, wait_exponential

logger = logging.getLogger("llm-red-team-ci.test_runner")

class TestRunner:
    """
    TestRunner executes adversarial prompts against the target LLM application.
    
    It supports different types of endpoints:
    - REST API endpoints
    - WebSocket endpoints
    - Web UI interfaces (using Playwright)
    """
    
    def __init__(self, api_endpoint: str, api_key: Optional[str] = None, service_tier: str = "standard"):
        """
        Initialize the TestRunner.
        
        Args:
            api_endpoint: The URL of the LLM application to test
            api_key: Optional API key for authentication
            service_tier: Service tier for test volume (basic, standard, premium)
        """
        self.api_endpoint = api_endpoint
        self.api_key = api_key
        self.service_tier = service_tier
        
        # Determine the endpoint type
        if api_endpoint.startswith("http"):
            if "websocket" in api_endpoint or "ws://" in api_endpoint or "wss://" in api_endpoint:
                self.endpoint_type = "websocket"
            else:
                self.endpoint_type = "rest"
        else:
            self.endpoint_type = "unknown"
        
        # Set request limits based on service tier
        self.rate_limits = {
            "basic": {"requests_per_minute": 10, "max_requests": 1000},
            "standard": {"requests_per_minute": 30, "max_requests": 5000},
            "premium": {"requests_per_minute": 100, "max_requests": 20000}
        }
        
        self.request_count = 0
        logger.info(f"TestRunner initialized with endpoint type: {self.endpoint_type}")
    
    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
    def execute_prompt(self, prompt) -> Dict[str, Any]:
        """
        Execute a prompt against the target LLM application.
        
        Args:
            prompt: The prompt object containing the adversarial prompt
            
        Returns:
            Dict containing the response from the LLM application
        """
        # Check if we've exceeded the request limit for the service tier
        if self.request_count >= self.rate_limits[self.service_tier]["max_requests"]:
            logger.warning(f"Request limit exceeded for {self.service_tier} tier")
            return {"error": "Request limit exceeded"}
        
        self.request_count += 1
        
        # Execute the prompt based on the endpoint type
        if self.endpoint_type == "rest":
            return self._execute_rest_prompt(prompt)
        elif self.endpoint_type == "websocket":
            return self._execute_websocket_prompt(prompt)
        else:
            return self._execute_playwright_prompt(prompt)
    
    def _execute_rest_prompt(self, prompt) -> Dict[str, Any]:
        """Execute a prompt against a REST API endpoint."""
        headers = {}
        if self.api_key:
            # Try common API key header formats
            headers = {
                "Authorization": f"Bearer {self.api_key}"
            }
        
        # Prepare the request payload based on common LLM API formats
        payload = {
            "prompt": prompt.text,
            "max_tokens": 1000,
            "temperature": 0.7,
            "model": "gpt-3.5-turbo"  # Default model, will be overridden by API
        }
        
        # Adjust payload based on prompt type and API format
        if hasattr(prompt, 'format_for_api'):
            payload = prompt.format_for_api(payload)
        
        try:
            response = requests.post(
                self.api_endpoint,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            # Log the response status
            logger.info(f"API response status: {response.status_code}")
            
            if response.status_code != 200:
                logger.warning(f"API returned non-200 status: {response.status_code}")
                return {
                    "status_code": response.status_code,
                    "error": f"API returned status {response.status_code}",
                    "response_text": response.text[:1000]  # Truncate long error responses
                }
            
            # Try to parse the response as JSON
            try:
                result = response.json()
            except json.JSONDecodeError:
                # If not JSON, return the raw text
                result = {"raw_text": response.text}
            
            # Add curl command for reproduction
            curl_command = self._generate_curl_command(prompt.text, headers)
            result["curl_command"] = curl_command
            
            return result
            
        except requests.RequestException as e:
            logger.error(f"Request failed: {e}")
            return {"error": str(e)}
    
    def _execute_websocket_prompt(self, prompt) -> Dict[str, Any]:
        """Execute a prompt against a WebSocket endpoint."""
        # WebSocket implementation would go here
        # For the MVP, we'll return a placeholder
        logger.warning("WebSocket execution not yet implemented")
        return {"error": "WebSocket execution not implemented yet"}
    
    def _execute_playwright_prompt(self, prompt) -> Dict[str, Any]:
        """Execute a prompt using Playwright for web UI testing."""
        logger.info("Using Playwright for web UI testing")
        
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                page = browser.new_page()
                
                # Navigate to the endpoint
                page.goto(self.api_endpoint)
                
                # Wait for the page to load
                page.wait_for_load_state("networkidle")
                
                # Try to find common chat input elements
                input_selectors = [
                    "textarea", 
                    "input[type='text']", 
                    "[contenteditable='true']",
                    ".chat-input",
                    "#prompt-textarea"
                ]
                
                input_element = None
                for selector in input_selectors:
                    try:
                        input_element = page.query_selector(selector)
                        if input_element:
                            break
                    except:
                        continue
                
                if not input_element:
                    logger.error("Could not find input element")
                    return {"error": "Could not find input element on page"}
                
                # Type the prompt
                input_element.fill(prompt.text)
                
                # Try to find and click a submit button
                submit_selectors = [
                    "button[type='submit']",
                    "button.submit",
                    "button.send",
                    ".send-button",
                    "button:has-text('Send')",
                    "button:has-text('Submit')"
                ]
                
                submit_button = None
                for selector in submit_selectors:
                    try:
                        submit_button = page.query_selector(selector)
                        if submit_button:
                            break
                    except:
                        continue
                
                if submit_button:
                    submit_button.click()
                else:
                    # Try pressing Enter if no submit button found
                    input_element.press("Enter")
                
                # Wait for response
                page.wait_for_timeout(5000)  # Wait 5 seconds for response
                
                # Try to capture the response
                response_selectors = [
                    ".chat-response",
                    ".response",
                    ".message:last-child",
                    ".assistant-message",
                    ".ai-response"
                ]
                
                response_text = ""
                for selector in response_selectors:
                    try:
                        response_element = page.query_selector(selector)
                        if response_element:
                            response_text = response_element.inner_text()
                            break
                    except:
                        continue
                
                # Take a screenshot for evidence
                screenshot_path = f"playwright_screenshot_{prompt.id}.png"
                page.screenshot(path=screenshot_path)
                
                browser.close()
                
                return {
                    "response_text": response_text,
                    "screenshot_path": screenshot_path,
                    "html": page.content()
                }
                
        except Exception as e:
            logger.error(f"Playwright execution failed: {e}")
            return {"error": str(e)}
    
    def _generate_curl_command(self, prompt_text: str, headers: Dict[str, str]) -> str:
        """Generate a curl command for reproducing the request."""
        header_args = " ".join([f'-H "{k}: {v}"' for k, v in headers.items()])
        
        # Escape quotes in the prompt text
        escaped_prompt = prompt_text.replace('"', '\\"')
        
        # Create a basic payload
        payload = {
            "prompt": escaped_prompt,
            "max_tokens": 1000
        }
        
        return f'curl -X POST {self.api_endpoint} {header_args} -d "{json.dumps(payload)}"'