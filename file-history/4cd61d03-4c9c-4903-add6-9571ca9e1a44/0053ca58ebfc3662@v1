#!/bin/bash
# V3 Autonomous Intelligence Daemon
# Runs continuously, monitors everything, acts proactively

DAEMON_PID=$$
LOG=~/.claude/logs/autonomous-daemon.log
STATE=~/.claude/memory/autonomous-state.json

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG"
}

# Initialize state
init_state() {
    cat > "$STATE" << 'EOJSON'
{
  "status": "running",
  "start_time": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
  "cycles": 0,
  "actions_taken": [],
  "context_preloaded": [],
  "suggestions_made": []
}
EOJSON
}

# Monitor git repositories using GitHub intelligence tracker
monitor_git() {
    # Use the new MCP GitHub tracker
    ~/.claude/scripts/mcp-github-tracker.sh daemon

    # Get quick status from Python integration
    local report=$(python3 ~/.claude/scripts/mcp-github-integration.py daemon-report 2>/dev/null)

    if [ $? -eq 0 ]; then
        local action_needed=$(echo "$report" | jq -r '.action_needed')
        local uncommitted=$(echo "$report" | jq -r '.metrics.uncommitted_files')
        local unpushed=$(echo "$report" | jq -r '.metrics.unpushed_commits')

        if [ "$action_needed" = "true" ]; then
            log "GitHub Intelligence: $uncommitted uncommitted files, $unpushed unpushed commits"

            # Record in state
            jq ".actions_taken += [\"GitHub tracking alert: action needed\"]" "$STATE" > /tmp/state.json && mv /tmp/state.json "$STATE"
        fi
    fi
}

# Predict next likely action based on time/context
predict_next_action() {
    HOUR=$(date +%H)
    
    # Evening pattern: usually work on sofia-pers
    if [ "$HOUR" -ge 18 ] && [ "$HOUR" -le 23 ]; then
        if [ ! -f /tmp/context-preloaded-sofia ]; then
            log "üîÆ PREDICTION: User likely to work on sofia-pers (evening pattern)"
            log "‚ö° PRE-LOADING: sofia-pers context..."
            
            # Pre-load context
            cd ~/Desktop/elvi/sofia-pers
            # Check if project is healthy
            if [ ! -d .venv ]; then
                log "‚ö†Ô∏è  PRE-CHECK: sofia-pers missing venv"
            fi
            
            touch /tmp/context-preloaded-sofia
        fi
    fi
}

# Monitor for error patterns
monitor_errors() {
    # Check if error rate increasing
    RECENT_ERRORS=$(tail -50 ~/.claude/memory/error-patterns.txt 2>/dev/null | wc -l)
    if [ "$RECENT_ERRORS" -gt 10 ]; then
        log "üö® ALERT: High error rate detected ($RECENT_ERRORS recent)"
        log "üí° SUGGESTION: Take a break? Error rate increases with fatigue"
    fi
}

# Proactive health checks
proactive_health_check() {
    # Check disk space
    DISK_USAGE=$(df -h . | tail -1 | awk '{print $5}' | sed 's/%//')
    if [ "$DISK_USAGE" -gt 80 ]; then
        log "‚ö†Ô∏è  ALERT: Disk usage $DISK_USAGE% - consider cleanup"
    fi
    
    # Check if learning daemon running
    if ! pgrep -f "learning-daemon.sh" > /dev/null; then
        log "‚ùå ALERT: Learning daemon stopped - attempting restart"
        ~/.claude/scripts/daemon-control.sh start
    fi
}

# Main autonomous loop
autonomous_loop() {
    log "üöÄ V3 Autonomous Daemon started (PID: $DAEMON_PID)"
    init_state
    
    CYCLE=0
    while true; do
        CYCLE=$((CYCLE + 1))
        
        # Update cycle count
        jq ".cycles = $CYCLE" "$STATE" > /tmp/state.json && mv /tmp/state.json "$STATE"
        
        # Execute autonomous functions
        monitor_git
        predict_next_action
        monitor_errors
        proactive_health_check
        
        # Sleep 60 seconds between cycles
        sleep 60
    done
}

# Start daemon
case "$1" in
    start)
        autonomous_loop &
        echo $! > ~/.claude/pids/autonomous-daemon.pid
        log "‚úÖ Autonomous daemon started"
        ;;
    stop)
        if [ -f ~/.claude/pids/autonomous-daemon.pid ]; then
            kill $(cat ~/.claude/pids/autonomous-daemon.pid)
            rm ~/.claude/pids/autonomous-daemon.pid
            log "üõë Autonomous daemon stopped"
        fi
        ;;
    status)
        if [ -f ~/.claude/pids/autonomous-daemon.pid ] && kill -0 $(cat ~/.claude/pids/autonomous-daemon.pid) 2>/dev/null; then
            echo "‚úÖ Autonomous daemon running"
            cat "$STATE" | jq .
        else
            echo "‚ùå Autonomous daemon not running"
        fi
        ;;
    *)
        echo "Usage: $0 {start|stop|status}"
        ;;
esac
