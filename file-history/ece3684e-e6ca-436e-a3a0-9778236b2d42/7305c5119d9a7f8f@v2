"""
TRUE LOCAL TTS - pyttsx3 (macOS native, zero network)
100% local, instant, works on Apple Silicon

Target: <150ms first-packet latency
"""
import time
import io
from loguru import logger
from typing import Generator
import pyttsx3


class LocalTTS:
    """
    100% Local TTS using macOS native speech synthesis

    Advantages:
    - Zero network latency (instant)
    - Native macOS voices
    - Works on Apple Silicon
    - True local (<150ms achievable)
    """

    def __init__(self, voice="com.apple.voice.compact.de-DE.Anna"):
        """
        Initialize local TTS with German voice

        Args:
            voice: macOS voice ID (Anna = German female)
        """
        self.engine = pyttsx3.init()

        # Set German voice
        voices = self.engine.getProperty('voices')
        german_voice = None
        for v in voices:
            if 'de' in v.id.lower() or 'german' in v.name.lower():
                german_voice = v
                break

        if german_voice:
            self.engine.setProperty('voice', german_voice.id)
            logger.info(f"Using voice: {german_voice.name}")

        # Set speaking rate (faster = lower latency)
        self.engine.setProperty('rate', 180)  # Default is ~200

        self.sample_rate = 22050  # macOS default

        logger.success(f"âœ… Local TTS initialized (macOS native, 100% LOCAL)")
        logger.info(f"   Expected: <150ms latency (zero network)")

    def speak(self, text: str) -> bytes:
        """
        Generate speech audio (100% local, instant)

        Args:
            text: Text to synthesize

        Returns:
            bytes: Raw PCM audio data
        """
        start_time = time.time()

        try:
            logger.debug(f"Generating speech (LOCAL macOS): {text[:50]}...")

            # Save to temporary WAV file
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as f:
                temp_file = f.name

            self.engine.save_to_file(text, temp_file)
            self.engine.runAndWait()

            # Read WAV file
            import wave
            with wave.open(temp_file, 'rb') as wf:
                audio_data = wf.readframes(wf.getnframes())

            # Clean up
            import os
            os.unlink(temp_file)

            latency = (time.time() - start_time) * 1000
            logger.success(f"ðŸŽ¯ LOCAL TTS latency: {latency:.0f}ms (target: <150ms)")

            return audio_data

        except Exception as e:
            logger.error(f"Local TTS error: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return b''

    def speak_stream_sentences(self, text: str) -> Generator[bytes, None, None]:
        """
        VoXtream-style streaming: Generate audio sentence-by-sentence

        Args:
            text: Full text to synthesize

        Yields:
            bytes: Audio data for each sentence
        """
        start_time = time.time()
        first_packet = True

        try:
            logger.debug(f"Streaming speech (LOCAL VoXtream): {text[:50]}...")

            # Split into sentences
            sentences = self._split_sentences(text)

            for i, sentence in enumerate(sentences):
                if not sentence.strip():
                    continue

                logger.debug(f"Generating sentence {i+1}/{len(sentences)}: {sentence[:30]}...")

                # Generate audio for this sentence (LOCAL = instant)
                audio_data = self.speak(sentence)

                if audio_data:
                    if first_packet:
                        latency = (time.time() - start_time) * 1000
                        logger.success(f"ðŸŽ¯ First-packet latency: {latency:.0f}ms (LOCAL, target: <150ms)")
                        first_packet = False

                    yield audio_data

        except Exception as e:
            logger.error(f"Local TTS streaming error: {e}")

    def _split_sentences(self, text: str) -> list:
        """
        Split text into sentences for incremental processing
        """
        sentences = []
        current = ""

        for char in text:
            current += char
            if char in '.!?' and len(current.strip()) > 3:
                sentences.append(current.strip())
                current = ""

        if current.strip():
            sentences.append(current.strip())

        logger.debug(f"Split into {len(sentences)} sentences")
        return sentences


# Backward compatibility
TextToSpeech = LocalTTS
PiperTTS = LocalTTS  # Alias for compatibility
