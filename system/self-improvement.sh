#!/bin/bash
# Claude Self-Improvement System
# Based on: RISE (arXiv:2407.18219), SEAL (arXiv:2506.10943)
# Purpose: Introspection, self-critique, and autonomous CLAUDE.md updates

set -euo pipefail

CLAUDE_HOME="$HOME/.claude"
INTROSPECTION_LOG="$CLAUDE_HOME/logs/introspection.log"
CLAUDE_MD="$CLAUDE_HOME/CLAUDE.md"
BACKUP_DIR="$CLAUDE_HOME/backups"

mkdir -p "$CLAUDE_HOME/logs" "$BACKUP_DIR"

log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" >> "$INTROSPECTION_LOG"
}

# Analyze what rules were followed vs missed
analyze_compliance() {
    local violations_log="$CLAUDE_HOME/logs/violations.log"

    if [ ! -f "$violations_log" ]; then
        echo "No violations log found"
        return
    fi

    log "=== INTROSPECTION CYCLE ==="

    # Count violation types
    local missed_todowrite
    missed_todowrite=$(grep -c "TodoWrite not used" "$violations_log" 2>/dev/null || echo "0")

    local missed_parallel
    missed_parallel=$(grep -c "sequential instead of parallel" "$violations_log" 2>/dev/null || echo "0")

    local missed_code_index
    missed_code_index=$(grep -c "without checking code index" "$violations_log" 2>/dev/null || echo "0")

    local missed_project_memory
    missed_project_memory=$(grep -c "without loading project memory" "$violations_log" 2>/dev/null || echo "0")

    log "Violations analysis:"
    log "  - Missed TodoWrite: $missed_todowrite"
    log "  - Missed parallel execution: $missed_parallel"
    log "  - Missed code index check: $missed_code_index"
    log "  - Missed project memory: $missed_project_memory"

    # Generate self-critique
    local critique=""

    if [ "$missed_todowrite" -gt 5 ]; then
        critique+="CRITIQUE: Consistently failing to use TodoWrite for complex tasks. Need stronger enforcement.\n"
    fi

    if [ "$missed_parallel" -gt 5 ]; then
        critique+="CRITIQUE: Not leveraging parallel execution enough. Default should be parallel.\n"
    fi

    if [ "$missed_code_index" -gt 3 ]; then
        critique+="CRITIQUE: Forgetting to check code index before grep. Add pre-Grep hook.\n"
    fi

    if [ -n "$critique" ]; then
        log "Self-critique generated:"
        echo -e "$critique" | while IFS= read -r line; do
            log "  $line"
        done

        # Save critique
        echo -e "$critique" > "$CLAUDE_HOME/reports/self-critique.txt"
    else
        log "No major issues detected. Compliance is good."
    fi
}

# Generate improvement suggestions for CLAUDE.md
generate_improvements() {
    local critique_file="$CLAUDE_HOME/reports/self-critique.txt"

    if [ ! -f "$critique_file" ]; then
        log "No critique file found. Skipping improvements."
        return
    fi

    log "Generating improvement suggestions..."

    local improvements_file="$CLAUDE_HOME/reports/suggested-improvements.md"

    cat > "$improvements_file" <<'EOF'
# Suggested CLAUDE.md Improvements
# Generated by self-improvement system

## Based on Recent Violations:

EOF

    # Parse critique and generate concrete improvements
    if grep -q "TodoWrite" "$critique_file"; then
        cat >> "$improvements_file" <<'EOF'
### 1. Stronger TodoWrite Enforcement

**Problem:** Consistently forgetting to use TodoWrite for complex tasks.

**Proposed Solution:**
```markdown
## MANDATORY: TodoWrite Auto-Activation

BEFORE responding to ANY user request:
1. Count the steps required (mental simulation)
2. IF steps >= 3 → MUST use TodoWrite (no exceptions)
3. IF steps < 3 → Direct execution

**Trigger phrases:**
- "implement", "build", "create", "add feature" → Auto-TodoWrite
- "fix multiple", "refactor", "migrate" → Auto-TodoWrite
- "analyze and improve" → Auto-TodoWrite
```

EOF
    fi

    if grep -q "parallel" "$critique_file"; then
        cat >> "$improvements_file" <<'EOF'
### 2. Parallel-First Execution

**Problem:** Running commands sequentially when they could be parallel.

**Proposed Solution:**
```markdown
## DEFAULT: Parallel Execution

ALWAYS assume parallel execution unless:
- Command B depends on output of Command A
- Sequence matters for correctness

**Rule:** When seeing multiple independent tasks → Single message, multiple tool calls

Example:
✅ GOOD: [Bash(git status), Bash(git diff), Bash(git log)] in ONE message
❌ BAD: Bash(git status) → wait → Bash(git diff) → wait → Bash(git log)
```

EOF
    fi

    if grep -q "code index" "$critique_file"; then
        cat >> "$improvements_file" <<'EOF'
### 3. Code Index Pre-Check Hook

**Problem:** Using Grep without checking code index first.

**Proposed Solution:**
```markdown
## PRE-GREP HOOK (Mandatory)

BEFORE using Grep tool:
1. Check: ls ~/.claude/memory/code-index/${PROJECT}/ 2>/dev/null
2. IF exists → grep code-index first
3. IF found in index → Use those locations directly
4. IF not in index → Then use Grep tool

**Saves 5-10 seconds per search**
```

EOF
    fi

    log "Improvements saved to: $improvements_file"
    echo "Review improvements: cat $improvements_file"
}

# Auto-apply safe improvements (with backup)
auto_apply_improvements() {
    local improvements_file="$CLAUDE_HOME/reports/suggested-improvements.md"

    if [ ! -f "$improvements_file" ]; then
        log "No improvements to apply"
        return
    fi

    # Backup current CLAUDE.md
    local backup_file="$BACKUP_DIR/CLAUDE.md.$(date +%Y%m%d-%H%M%S)"
    cp "$CLAUDE_MD" "$backup_file"
    log "Backup created: $backup_file"

    # For now, just log that manual review is needed
    log "Improvements ready for review. Manual application recommended."
    log "To apply: Review $improvements_file and update $CLAUDE_MD"

    # Future: Could implement auto-patching with safety checks
}

# Main introspection cycle
case "${1:-analyze}" in
    analyze)
        analyze_compliance
        ;;
    improve)
        generate_improvements
        ;;
    apply)
        auto_apply_improvements
        ;;
    full)
        analyze_compliance
        generate_improvements
        auto_apply_improvements
        ;;
    *)
        echo "Usage: $0 {analyze|improve|apply|full}"
        exit 1
        ;;
esac
